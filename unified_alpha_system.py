"""
ÌÜµÌï© ÏïåÌåå Ìå©ÌÑ∞ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏãúÏä§ÌÖú
Î™®Îì† Î™®ÎìàÏùÑ ÌÜµÌï©Ìïú ÏôÑÏ†ÑÌïú Ìà¨Ïûê Î∂ÑÏÑù Î∞è Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú

ÏûëÏÑ±Ïûê: AI Assistant
ÏûëÏÑ±Ïùº: 2025ÎÖÑ 1Ïõî
Î≤ÑÏ†Ñ: 1.0 (ÌÜµÌï© Î≤ÑÏ†Ñ)
"""

import pandas as pd
import numpy as np
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import yfinance as yf
from typing import Dict, List, Optional, Tuple, Any, Union
from datetime import datetime, timedelta
from dataclasses import dataclass
import warnings
import logging

# Î°úÏª¨ Î™®Îìà imports
from alpha_factor_library import EnhancedFactorLibrary, FactorValidator, ensure_numeric_dataframe, ensure_numeric_series
from backtesting_engine import BacktestEngine, BacktestConfig, BacktestResults
from portfolio_optimizer import PortfolioOptimizer, OptimizationConstraints
from database import DatabaseManager
from zscore import FactorZScoreCalculator

warnings.filterwarnings('ignore')
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class UnifiedSystemConfig:
    """ÌÜµÌï© ÏãúÏä§ÌÖú ÏÑ§Ï†ï"""
    # Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
    start_date: datetime = datetime.now() - timedelta(days=730)  # 2ÎÖÑ
    end_date: datetime = datetime.now()
    
    # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÑ§Ï†ï
    initial_capital: float = 1000000  # 100ÎßåÏõê
    max_position_size: float = 0.15   # ÏµúÎåÄ 15%
    min_position_size: float = 0.01   # ÏµúÏÜå 1%
    transaction_cost: float = 0.001   # 0.1%
    
    # Ìå©ÌÑ∞ ÏÑ§Ï†ï
    enable_zscore: bool = True
    enable_ensemble: bool = True
    enable_hedging: bool = True
    
    # Z-Score ÏûÑÍ≥ÑÍ∞í
    zscore_threshold_high: float = 1.5
    zscore_threshold_low: float = -1.5
    
    # Î¶¨Î∞∏Îü∞Ïã±
    rebalance_frequency: str = 'monthly'

class UnifiedAlphaSystem:
    """ÌÜµÌï© ÏïåÌåå Ìå©ÌÑ∞ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏãúÏä§ÌÖú"""
    
    def __init__(self, config: UnifiedSystemConfig = None):
        if config is None:
            config = UnifiedSystemConfig()
        
        self.config = config
        
        # ÌïµÏã¨ ÏóîÏßÑÎì§ Ï¥àÍ∏∞Ìôî
        self.factor_engine = EnhancedFactorLibrary()
        self.zscore_calculator = FactorZScoreCalculator()
        self.backtest_engine = BacktestEngine(BacktestConfig(
            start_date=config.start_date,
            end_date=config.end_date,
            initial_capital=config.initial_capital,
            rebalance_frequency=config.rebalance_frequency,
            transaction_cost=config.transaction_cost
        ))
        self.optimizer = PortfolioOptimizer()
        self.database = DatabaseManager()
        self.validator = FactorValidator()
        
        # Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞
        self.cached_data = {}
        self.cached_factors = {}
        
    def load_market_data(self, tickers: List[str], period: str = "2y") -> Dict[str, pd.DataFrame]:
        """ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î°úÎî©"""
        try:
            data = {}
            
            st.info(f"üìä {len(tickers)}Í∞ú Ï¢ÖÎ™© Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...")
            progress_bar = st.progress(0)
            
            for i, ticker in enumerate(tickers):
                try:
                    # Ï∫êÏãú ÌôïÏù∏
                    cache_key = f"{ticker}_{period}"
                    if cache_key in self.cached_data:
                        data[ticker] = self.cached_data[cache_key]
                        continue
                    
                    # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Î®ºÏ†Ä ÌôïÏù∏
                    cached_data = self.database.get_cached_market_data(
                        ticker, 
                        self.config.start_date.strftime('%Y-%m-%d'),
                        self.config.end_date.strftime('%Y-%m-%d')
                    )
                    
                    if cached_data is not None and len(cached_data) > 100:
                        data[ticker] = cached_data
                        self.cached_data[cache_key] = cached_data
                    else:
                        # Yahoo FinanceÏóêÏÑú ÏÉàÎ°ú Îã§Ïö¥Î°úÎìú
                        stock = yf.Ticker(ticker)
                        hist = stock.history(period=period)
                        
                        if len(hist) > 50:
                            hist = ensure_numeric_dataframe(hist)
                            data[ticker] = hist
                            self.cached_data[cache_key] = hist
                            
                            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï∫êÏãú
                            self.database.cache_market_data(hist, ticker)
                
                except Exception as e:
                    logger.error(f"Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå® {ticker}: {str(e)}")
                    continue
                
                progress_bar.progress((i + 1) / len(tickers))
            
            progress_bar.empty()
            
            if data:
                st.success(f"‚úÖ {len(data)}Í∞ú Ï¢ÖÎ™© Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏôÑÎ£å")
            else:
                st.error("‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®")
            
            return data
            
        except Exception as e:
            logger.error(f"ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïò§Î•ò: {str(e)}")
            st.error(f"Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïò§Î•ò: {str(e)}")
            return {}
    
    def process_market_data(self, raw_data: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
        """ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨"""
        try:
            processed_data = {
                'prices': pd.DataFrame(),
                'volumes': pd.DataFrame(),
                'returns': pd.DataFrame()
            }
            
            # Í∞ÄÍ≤© Î∞è Í±∞ÎûòÎüâ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
            for ticker, data in raw_data.items():
                if 'Close' in data.columns:
                    processed_data['prices'][ticker] = data['Close']
                if 'Volume' in data.columns:
                    processed_data['volumes'][ticker] = data['Volume']
            
            # ÏàòÏùµÎ•† Í≥ÑÏÇ∞
            if not processed_data['prices'].empty:
                processed_data['returns'] = processed_data['prices'].pct_change()
            
            # Í≤∞Ï∏°Ïπò Ï†úÍ±∞ Î∞è Ï†ïÎ†¨
            for key in processed_data:
                if not processed_data[key].empty:
                    processed_data[key] = ensure_numeric_dataframe(processed_data[key])
                    processed_data[key] = processed_data[key].dropna(how='all')
                    processed_data[key] = processed_data[key].sort_index()
            
            return processed_data
            
        except Exception as e:
            logger.error(f"Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ Ïò§Î•ò: {str(e)}")
            return {}
    
    def calculate_all_factors(self, data: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Î™®Îì† Ìå©ÌÑ∞ Í≥ÑÏÇ∞ (Z-Score Ìè¨Ìï®)"""
        try:
            if not data or 'prices' not in data:
                return {}
            
            results = {
                'raw_factors': {},
                'zscore_factors': {},
                'percentile_ranks': {},
                'factor_statistics': {},
                'factor_correlation': pd.DataFrame()
            }
            
            st.info("üî¢ Ìå©ÌÑ∞ Í≥ÑÏÇ∞ Ï§ë...")
            progress = st.progress(0)
            
            # 1. Í∏∞Î≥∏ Ìå©ÌÑ∞Îì§ Í≥ÑÏÇ∞
            factor_categories = ['technical', 'advanced_technical', 'machine_learning', 'risk']
            factor_types = {
                'technical': ['momentum', 'mean_reversion', 'volatility', 'volume'],
                'advanced_technical': ['rsi', 'bollinger_bands', 'zscore', 'correlation'],
                'machine_learning': ['random_forest', 'pca'],
                'risk': ['beta', 'downside_risk']
            }
            
            total_factors = sum(len(types) for types in factor_types.values())
            current_step = 0
            
            for category in factor_categories:
                results['raw_factors'][category] = {}
                
                for factor_name in factor_types[category]:
                    try:
                        factor_data = self.factor_engine.calculate_factor(
                            category, factor_name, data
                        )
                        
                        if not factor_data.empty:
                            results['raw_factors'][category][factor_name] = factor_data
                        
                    except Exception as e:
                        logger.error(f"Ìå©ÌÑ∞ Í≥ÑÏÇ∞ Ïã§Ìå® {category}.{factor_name}: {str(e)}")
                    
                    current_step += 1
                    progress.progress(current_step / (total_factors + 3))
            
            # 2. Z-Score Í∏∞Î∞ò Ìå©ÌÑ∞Îì§ Í≥ÑÏÇ∞ (zscore.py Î™®Îìà ÌôúÏö©)
            if self.config.enable_zscore:
                zscore_factors = self.calculate_zscore_factors(data)
                results['zscore_factors'] = zscore_factors
                
                # Î∞±Î∂ÑÏúÑ ÏàúÏúÑ Í≥ÑÏÇ∞
                for factor_type, scores in zscore_factors.items():
                    if isinstance(scores, pd.Series) and not scores.empty:
                        results['percentile_ranks'][factor_type] = \
                            self.zscore_calculator.calculate_percentile_rank(scores)
                
                # Ìå©ÌÑ∞ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
                for factor_type, scores in zscore_factors.items():
                    if isinstance(scores, pd.Series) and not scores.empty:
                        results['factor_statistics'][factor_type] = \
                            self.zscore_calculator.get_factor_statistics(scores)
            
            progress.progress(0.9)
            
            # 3. Ìå©ÌÑ∞ ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ Í≥ÑÏÇ∞
            if results['zscore_factors']:
                correlation_data = pd.DataFrame()
                for factor_type, scores in results['zscore_factors'].items():
                    if isinstance(scores, pd.Series) and not scores.empty:
                        correlation_data[factor_type] = scores
                
                if not correlation_data.empty:
                    results['factor_correlation'] = \
                        self.zscore_calculator.calculate_factor_correlation(correlation_data)
            
            progress.progress(1.0)
            progress.empty()
            
            st.success("‚úÖ Ìå©ÌÑ∞ Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return results
            
        except Exception as e:
            logger.error(f"Ìå©ÌÑ∞ Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            st.error(f"Ìå©ÌÑ∞ Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            return {}
    
    def calculate_zscore_factors(self, data: Dict[str, pd.DataFrame]) -> Dict[str, pd.Series]:
        """Z-Score Í∏∞Î∞ò Ìå©ÌÑ∞ Í≥ÑÏÇ∞"""
        try:
            zscore_factors = {}
            
            if 'prices' not in data:
                return zscore_factors
            
            price_data = data['prices']
            volume_data = data.get('volumes')
            
            # Value Ìå©ÌÑ∞
            value_data = self.zscore_calculator.calculate_value_factor(price_data, volume_data)
            if not value_data.empty:
                zscore_factors['value'] = self.zscore_calculator.calculate_factor_zscore(
                    value_data, 'value'
                )
            
            # Quality Ìå©ÌÑ∞
            quality_data = self.zscore_calculator.calculate_quality_factor(price_data, volume_data)
            if not quality_data.empty:
                zscore_factors['quality'] = self.zscore_calculator.calculate_factor_zscore(
                    quality_data, 'quality'
                )
            
            # Momentum Ìå©ÌÑ∞
            momentum_data = self.zscore_calculator.calculate_momentum_factor(price_data)
            if not momentum_data.empty:
                zscore_factors['momentum'] = self.zscore_calculator.calculate_factor_zscore(
                    momentum_data, 'momentum'
                )
            
            return zscore_factors
            
        except Exception as e:
            logger.error(f"Z-Score Ìå©ÌÑ∞ Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            return {}
    
    def create_unified_portfolio(self, data: Dict[str, pd.DataFrame], 
                               factor_results: Dict[str, Any]) -> Dict[str, Any]:
        """ÌÜµÌï© Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÉùÏÑ±"""
        try:
            if not factor_results or 'zscore_factors' not in factor_results:
                return {}
            
            results = {}
            
            # 1. Z-Score Í∏∞Î∞ò Î≥µÌï© Ï†êÏàò Í≥ÑÏÇ∞
            composite_score = self.calculate_composite_score(factor_results['zscore_factors'])
            results['composite_score'] = composite_score
            
            # 2. Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌõÑÎ≥¥ ÏÑ†Î≥Ñ
            portfolio_candidates = self.select_portfolio_candidates(composite_score)
            results['candidates'] = portfolio_candidates
            
            # 3. Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏµúÏ†ÅÌôî
            if portfolio_candidates['long_positions'] is not None:
                optimized_portfolio = self.optimize_portfolio(
                    data, portfolio_candidates, factor_results
                )
                results['optimized_portfolio'] = optimized_portfolio
            
            # 4. Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù
            risk_analysis = self.analyze_portfolio_risk(
                data, results.get('optimized_portfolio', {})
            )
            results['risk_analysis'] = risk_analysis
            
            # 5. Î∞±ÌÖåÏä§ÌåÖ
            if 'optimized_portfolio' in results:
                backtest_results = self.run_comprehensive_backtest(
                    data, results['optimized_portfolio']
                )
                results['backtest_results'] = backtest_results
            
            return results
            
        except Exception as e:
            logger.error(f"ÌÜµÌï© Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {}
    
    def calculate_composite_score(self, zscore_factors: Dict[str, pd.Series]) -> pd.Series:
        """Î≥µÌï© Ìå©ÌÑ∞ Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            if not zscore_factors:
                return pd.Series()
            
            # Ìå©ÌÑ∞Î≥Ñ Í∞ÄÏ§ëÏπò (ÏÑ§Ï†ï Í∞ÄÎä•)
            weights = {
                'value': 0.4,
                'quality': 0.3, 
                'momentum': 0.3
            }
            
            # ÏµúÏã† ÎÇ†ÏßúÏùò Ï†êÏàòÎì§Îßå ÏÇ¨Ïö©
            latest_scores = {}
            for factor_type, scores in zscore_factors.items():
                if isinstance(scores, pd.Series) and not scores.empty:
                    latest_scores[factor_type] = scores.iloc[-1] if len(scores) > 0 else 0
            
            # Í∞ÄÏ§ë ÌèâÍ∑† Í≥ÑÏÇ∞
            composite_score = pd.Series(0.0, index=latest_scores.get('value', pd.Series()).index)
            
            for factor_type, weight in weights.items():
                if factor_type in latest_scores:
                    factor_scores = latest_scores[factor_type]
                    if isinstance(factor_scores, (pd.Series, dict)):
                        composite_score += factor_scores * weight
            
            return composite_score
            
        except Exception as e:
            logger.error(f"Î≥µÌï© Ï†êÏàò Í≥ÑÏÇ∞ Ïò§Î•ò: {str(e)}")
            return pd.Series()
    
    def select_portfolio_candidates(self, composite_score: pd.Series) -> Dict[str, Any]:
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌõÑÎ≥¥ ÏÑ†Î≥Ñ"""
        try:
            if composite_score.empty:
                return {'long_positions': None, 'short_positions': None}
            
            # Z-Score ÏûÑÍ≥ÑÍ∞í Í∏∞Ï§ÄÏúºÎ°ú ÏÑ†Î≥Ñ
            high_score = composite_score[composite_score > self.config.zscore_threshold_high]
            low_score = composite_score[composite_score < self.config.zscore_threshold_low]
            
            # ÏÉÅÏúÑ/ÌïòÏúÑ NÍ∞ú ÏÑ†Î≥Ñ (ÏûÑÍ≥ÑÍ∞íÏóê ÏÉÅÍ¥ÄÏóÜÏù¥)
            n_positions = min(10, len(composite_score) // 2)
            top_positions = composite_score.nlargest(n_positions)
            bottom_positions = composite_score.nsmallest(n_positions)
            
            return {
                'long_positions': top_positions,
                'short_positions': bottom_positions,
                'high_zscore': high_score,
                'low_zscore': low_score,
                'all_scores': composite_score
            }
            
        except Exception as e:
            logger.error(f"Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌõÑÎ≥¥ ÏÑ†Î≥Ñ Ïò§Î•ò: {str(e)}")
            return {'long_positions': None, 'short_positions': None}
    
    def optimize_portfolio(self, data: Dict[str, pd.DataFrame], 
                          candidates: Dict[str, Any],
                          factor_results: Dict[str, Any]) -> Dict[str, Any]:
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏµúÏ†ÅÌôî"""
        try:
            if not candidates['long_positions'] is not None:
                return {}
            
            # ÏµúÏ†ÅÌôî Ï†úÏïΩÏ°∞Í±¥ ÏÑ§Ï†ï
            constraints = OptimizationConstraints(
                max_weight=self.config.max_position_size,
                min_weight=self.config.min_position_size,
                long_only=True,
                leverage=1.0
            )
            
            # Í∏∞ÎåÄÏàòÏùµÎ•†Î°ú Î≥µÌï© Ï†êÏàò ÏÇ¨Ïö©
            expected_returns = candidates['long_positions'] / candidates['long_positions'].std()
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏµúÏ†ÅÌôî Ïã§Ìñâ
            optimization_result = self.optimizer.optimize_portfolio(
                returns=data['returns'],
                factor_scores=pd.DataFrame({'composite': expected_returns}),
                method='mean_variance',
                constraints=constraints
            )
            
            return {
                'weights': optimization_result.weights,
                'expected_return': optimization_result.expected_return,
                'expected_volatility': optimization_result.expected_volatility,
                'sharpe_ratio': optimization_result.sharpe_ratio,
                'optimization_status': optimization_result.optimization_status
            }
            
        except Exception as e:
            logger.error(f"Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏµúÏ†ÅÌôî Ïò§Î•ò: {str(e)}")
            return {}
    
    def analyze_portfolio_risk(self, data: Dict[str, pd.DataFrame], 
                             portfolio: Dict[str, Any]) -> Dict[str, Any]:
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù"""
        try:
            if not portfolio or 'weights' not in portfolio:
                return {}
            
            weights = portfolio['weights']
            returns = data.get('returns', pd.DataFrame())
            
            if returns.empty:
                return {}
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏàòÏùµÎ•† Í≥ÑÏÇ∞
            common_assets = weights.index.intersection(returns.columns)
            if len(common_assets) == 0:
                return {}
            
            aligned_weights = weights[common_assets]
            aligned_returns = returns[common_assets]
            
            portfolio_returns = (aligned_returns * aligned_weights).sum(axis=1)
            
            # Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú Í≥ÑÏÇ∞
            risk_metrics = {
                'portfolio_volatility': portfolio_returns.std() * np.sqrt(252),
                'var_95': portfolio_returns.quantile(0.05),
                'var_99': portfolio_returns.quantile(0.01),
                'max_drawdown': self.calculate_max_drawdown(portfolio_returns),
                'sharpe_ratio': portfolio_returns.mean() / portfolio_returns.std() * np.sqrt(252) if portfolio_returns.std() > 0 else 0,
                'sortino_ratio': self.calculate_sortino_ratio(portfolio_returns),
                'beta': self.calculate_beta(portfolio_returns, returns.mean(axis=1))
            }
            
            return risk_metrics
            
        except Exception as e:
            logger.error(f"Î¶¨Ïä§ÌÅ¨ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {}
    
    def calculate_max_drawdown(self, returns: pd.Series) -> float:
        """ÏµúÎåÄ ÏÜêÏã§ Í≥ÑÏÇ∞"""
        try:
            cumulative = (1 + returns).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            return drawdown.min()
        except:
            return 0.0
    
    def calculate_sortino_ratio(self, returns: pd.Series) -> float:
        """ÏÜåÎ•¥Ìã∞ÎÖ∏ ÎπÑÏú® Í≥ÑÏÇ∞"""
        try:
            downside_returns = returns[returns < 0]
            if len(downside_returns) == 0:
                return 0.0
            downside_std = downside_returns.std()
            return returns.mean() / downside_std * np.sqrt(252) if downside_std > 0 else 0.0
        except:
            return 0.0
    
    def calculate_beta(self, portfolio_returns: pd.Series, market_returns: pd.Series) -> float:
        """Î≤†ÌÉÄ Í≥ÑÏÇ∞"""
        try:
            covariance = np.cov(portfolio_returns, market_returns)[0, 1]
            market_variance = np.var(market_returns)
            return covariance / market_variance if market_variance > 0 else 1.0
        except:
            return 1.0
    
    def run_comprehensive_backtest(self, data: Dict[str, pd.DataFrame],
                                 portfolio: Dict[str, Any]) -> Dict[str, Any]:
        """Ï¢ÖÌï© Î∞±ÌÖåÏä§ÌåÖ"""
        try:
            if not portfolio or 'weights' not in portfolio:
                return {}
            
            weights = portfolio['weights']
            
            # Ìå©ÌÑ∞ Ï†êÏàòÎ•º DataFrame ÌòïÌÉúÎ°ú Î≥ÄÌôò
            factor_scores = pd.DataFrame()
            for date in data['returns'].index:
                factor_scores.loc[date, weights.index] = weights.values
            
            # Î∞±ÌÖåÏä§ÌåÖ Ïã§Ìñâ
            backtest_results = self.backtest_engine.run_backtest(
                factor_scores=factor_scores,
                returns=data['returns'],
                portfolio_method='factor_weight',
                n_assets=len(weights)
            )
            
            return {
                'portfolio_returns': backtest_results.portfolio_returns,
                'performance_metrics': backtest_results.performance_metrics,
                'turnover': backtest_results.turnover.mean() if not backtest_results.turnover.empty else 0,
                'transaction_costs': backtest_results.transaction_costs.sum() if not backtest_results.transaction_costs.empty else 0
            }
            
        except Exception as e:
            logger.error(f"Î∞±ÌÖåÏä§ÌåÖ Ïò§Î•ò: {str(e)}")
            return {}
    
    def generate_alerts(self, factor_results: Dict[str, Any], 
                       portfolio_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ÏïåÎ¶º ÏÉùÏÑ±"""
        try:
            alerts = []
            
            # Z-Score Í∏∞Î∞ò ÏïåÎ¶º
            if 'zscore_factors' in factor_results:
                for factor_type, scores in factor_results['zscore_factors'].items():
                    if isinstance(scores, pd.Series) and not scores.empty:
                        latest_score = scores.iloc[-1] if len(scores) > 0 else 0
                        
                        if abs(latest_score) > 2.0:
                            alerts.append({
                                'type': 'EXTREME_FACTOR',
                                'factor': factor_type,
                                'value': latest_score,
                                'message': f"{factor_type} Ìå©ÌÑ∞Í∞Ä Í∑πÎã®Í∞í ({latest_score:.2f})Ïóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§.",
                                'severity': 'HIGH'
                            })
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î¶¨Ïä§ÌÅ¨ ÏïåÎ¶º
            if 'risk_analysis' in portfolio_results:
                risk = portfolio_results['risk_analysis']
                
                if risk.get('portfolio_volatility', 0) > 0.25:
                    alerts.append({
                        'type': 'HIGH_VOLATILITY',
                        'value': risk['portfolio_volatility'],
                        'message': f"Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î≥ÄÎèôÏÑ±Ïù¥ ÎÜíÏäµÎãàÎã§ ({risk['portfolio_volatility']:.1%})",
                        'severity': 'MEDIUM'
                    })
                
                if risk.get('max_drawdown', 0) < -0.2:
                    alerts.append({
                        'type': 'HIGH_DRAWDOWN', 
                        'value': risk['max_drawdown'],
                        'message': f"ÏµúÎåÄ ÏÜêÏã§Ïù¥ ÌÅΩÎãàÎã§ ({risk['max_drawdown']:.1%})",
                        'severity': 'HIGH'
                    })
            
            return alerts
            
        except Exception as e:
            logger.error(f"ÏïåÎ¶º ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return []
    
    def save_results_to_database(self, results: Dict[str, Any]):
        """Í≤∞Í≥ºÎ•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•"""
        try:
            # Ìå©ÌÑ∞ Í≤∞Í≥º Ï†ÄÏû•
            if 'factor_results' in results:
                for category, factors in results['factor_results'].get('raw_factors', {}).items():
                    for factor_name, factor_data in factors.items():
                        if not factor_data.empty:
                            # Ìå©ÌÑ∞ Ï†ïÏùò Ï†ÄÏû•
                            factor_id = self.database.save_factor_definition(
                                name=f"{category}_{factor_name}",
                                category=category,
                                description=self.factor_engine.get_factor_description(category, factor_name)
                            )
                            
                            # Ìå©ÌÑ∞ Í∞í Ï†ÄÏû•
                            if isinstance(factor_data, pd.DataFrame):
                                self.database.save_factor_values(factor_id, factor_data)
            
            # Î∞±ÌÖåÏä§ÌåÖ Í≤∞Í≥º Ï†ÄÏû•
            if 'portfolio_results' in results and 'backtest_results' in results['portfolio_results']:
                backtest = results['portfolio_results']['backtest_results']
                if 'performance_metrics' in backtest:
                    self.database.save_backtest_results(
                        factor_id=1,  # ÌÜµÌï© Ìå©ÌÑ∞ ID
                        config=self.config.__dict__,
                        performance_metrics=backtest['performance_metrics'],
                        portfolio_returns=backtest.get('portfolio_returns', pd.Series())
                    )
            
            logger.info("Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïò§Î•ò: {str(e)}")
    
    def run_complete_analysis(self, tickers: List[str]) -> Dict[str, Any]:
        """ÏôÑÏ†ÑÌïú Î∂ÑÏÑù ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìñâ"""
        try:
            st.header("üöÄ ÌÜµÌï© ÏïåÌåå Ìå©ÌÑ∞ Î∂ÑÏÑù ÏãúÏä§ÌÖú")
            st.write("Î™®Îì† Î™®ÎìàÏùÑ ÌÜµÌï©Ìïú ÏôÑÏ†ÑÌïú Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î∂ÑÏÑùÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.")
            
            results = {}
            
            # 1. Îç∞Ïù¥ÌÑ∞ Î°úÎî©
            with st.expander("üìä 1Îã®Í≥Ñ: ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Î°úÎî©", expanded=True):
                raw_data = self.load_market_data(tickers)
                if not raw_data:
                    st.error("‚ùå Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®")
                    return {}
                
                processed_data = self.process_market_data(raw_data)
                results['market_data'] = processed_data
                
                st.success(f"‚úÖ {len(processed_data['prices'].columns)}Í∞ú Ï¢ÖÎ™© Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ ÏôÑÎ£å")
            
            # 2. Ìå©ÌÑ∞ Î∂ÑÏÑù
            with st.expander("üî¢ 2Îã®Í≥Ñ: Ìå©ÌÑ∞ Î∂ÑÏÑù (Z-Score Ìè¨Ìï®)", expanded=True):
                factor_results = self.calculate_all_factors(processed_data)
                results['factor_results'] = factor_results
                
                if factor_results:
                    st.success("‚úÖ Ìå©ÌÑ∞ Î∂ÑÏÑù ÏôÑÎ£å")
                    
                    # Ìå©ÌÑ∞ ÏöîÏïΩ ÌëúÏãú
                    self.display_factor_summary(factor_results)
                else:
                    st.error("‚ùå Ìå©ÌÑ∞ Î∂ÑÏÑù Ïã§Ìå®")
            
            # 3. Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ±
            with st.expander("üìà 3Îã®Í≥Ñ: ÌÜµÌï© Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ±", expanded=True):
                portfolio_results = self.create_unified_portfolio(processed_data, factor_results)
                results['portfolio_results'] = portfolio_results
                
                if portfolio_results:
                    st.success("‚úÖ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ± ÏôÑÎ£å")
                    
                    # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÏöîÏïΩ ÌëúÏãú
                    self.display_portfolio_summary(portfolio_results)
                else:
                    st.error("‚ùå Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ± Ïã§Ìå®")
            
            # 4. ÏïåÎ¶º Î∞è Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨
            with st.expander("‚ö†Ô∏è 4Îã®Í≥Ñ: ÏïåÎ¶º Î∞è Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨", expanded=True):
                alerts = self.generate_alerts(factor_results, portfolio_results)
                results['alerts'] = alerts
                
                self.display_alerts(alerts)
            
            # 5. Ï¢ÖÌï© ÎåÄÏãúÎ≥¥Îìú
            with st.expander("üìä 5Îã®Í≥Ñ: Ï¢ÖÌï© Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú", expanded=True):
                self.display_comprehensive_dashboard(results)
            
            # 6. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•
            if st.button("üíæ Í≤∞Í≥º Ï†ÄÏû•"):
                self.save_results_to_database(results)
                st.success("‚úÖ Í≤∞Í≥ºÍ∞Ä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")
            
            return results
            
        except Exception as e:
            logger.error(f"ÏôÑÏ†Ñ Î∂ÑÏÑù Ïã§Ìñâ Ïò§Î•ò: {str(e)}")
            st.error(f"Î∂ÑÏÑù Ïã§Ìñâ Ïò§Î•ò: {str(e)}")
            return {}

    # UI ÌëúÏãú Î©îÏÑúÎìúÎì§ÏùÄ Îã§Ïùå ÌååÏùºÏóêÏÑú Í≥ÑÏÜçÎê©ÎãàÎã§...
    
    def display_factor_summary(self, factor_results: Dict[str, Any]):
        """Ìå©ÌÑ∞ Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ ÌëúÏãú"""
        if 'zscore_factors' in factor_results and factor_results['zscore_factors']:
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**Z-Score Ìå©ÌÑ∞ ÌòÑÌô©**")
                summary_data = []
                
                for factor_type, scores in factor_results['zscore_factors'].items():
                    if isinstance(scores, pd.Series) and not scores.empty:
                        latest_score = scores.iloc[-1] if len(scores) > 0 else 0
                        summary_data.append({
                            'Factor': factor_type.title(),
                            'Latest Z-Score': f"{latest_score:.3f}",
                            'Signal': 'üî¥ Îß§ÎèÑ' if latest_score < -1 else 'üü° Ï§ëÎ¶Ω' if abs(latest_score) < 1 else 'üü¢ Îß§Ïàò'
                        })
                
                if summary_data:
                    st.dataframe(pd.DataFrame(summary_data))
            
            with col2:
                if 'factor_correlation' in factor_results and not factor_results['factor_correlation'].empty:
                    st.write("**Ìå©ÌÑ∞ ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ**")
                    fig = px.imshow(
                        factor_results['factor_correlation'],
                        title="Ìå©ÌÑ∞ Í∞Ñ ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ",
                        color_continuous_scale='RdBu_r',
                        aspect='auto'
                    )
                    fig.update_layout(height=300)
                    st.plotly_chart(fig, use_container_width=True)
    
    def display_portfolio_summary(self, portfolio_results: Dict[str, Any]):
        """Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í≤∞Í≥º ÏöîÏïΩ ÌëúÏãú"""
        if 'optimized_portfolio' in portfolio_results:
            portfolio = portfolio_results['optimized_portfolio']
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric(
                    "ÏòàÏÉÅ Ïó∞ÏàòÏùµÎ•†",
                    f"{portfolio.get('expected_return', 0) * 100:.2f}%"
                )
            
            with col2:
                st.metric(
                    "ÏòàÏÉÅ Î≥ÄÎèôÏÑ±", 
                    f"{portfolio.get('expected_volatility', 0) * 100:.2f}%"
                )
            
            with col3:
                st.metric(
                    "ÏÉ§ÌîÑ ÎπÑÏú®",
                    f"{portfolio.get('sharpe_ratio', 0):.3f}"
                )
            
            # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ± ÌëúÏãú
            if 'weights' in portfolio:
                weights = portfolio['weights']
                if not weights.empty:
                    st.write("**Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Íµ¨ÏÑ±**")
                    
                    # ÏÉÅÏúÑ 10Í∞ú Ï¢ÖÎ™©Îßå ÌëúÏãú
                    top_weights = weights.sort_values(ascending=False).head(10)
                    
                    fig = px.bar(
                        x=top_weights.values * 100,
                        y=top_weights.index,
                        orientation='h',
                        title="Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÎπÑÏ§ë (ÏÉÅÏúÑ 10Í∞ú)",
                        labels={'x': 'ÎπÑÏ§ë (%)', 'y': 'Ï¢ÖÎ™©'}
                    )
                    fig.update_layout(height=400)
                    st.plotly_chart(fig, use_container_width=True)
    
    def display_alerts(self, alerts: List[Dict[str, Any]]):
        """ÏïåÎ¶º ÌëúÏãú"""
        if not alerts:
            st.success("‚úÖ ÌòÑÏû¨ ÌäπÎ≥ÑÌïú ÏïåÎ¶ºÏù¥ ÏóÜÏäµÎãàÎã§.")
            return
        
        for alert in alerts:
            severity = alert.get('severity', 'LOW')
            
            if severity == 'HIGH':
                st.error(f"üö® {alert['message']}")
            elif severity == 'MEDIUM':
                st.warning(f"‚ö†Ô∏è {alert['message']}")
            else:
                st.info(f"‚ÑπÔ∏è {alert['message']}")
    
    def display_comprehensive_dashboard(self, results: Dict[str, Any]):
        """Ï¢ÖÌï© Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú"""
        if 'portfolio_results' in results and 'backtest_results' in results['portfolio_results']:
            backtest = results['portfolio_results']['backtest_results']
            
            if 'portfolio_returns' in backtest and not backtest['portfolio_returns'].empty:
                returns = backtest['portfolio_returns']
                
                # ÏàòÏùµÎ•† Ï∞®Ìä∏
                cumulative_returns = (1 + returns).cumprod()
                
                fig = go.Figure()
                fig.add_trace(go.Scatter(
                    x=cumulative_returns.index,
                    y=cumulative_returns.values,
                    mode='lines',
                    name='ÎàÑÏ†Å ÏàòÏùµÎ•†',
                    line=dict(color='blue', width=2)
                ))
                
                fig.update_layout(
                    title="Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÎàÑÏ†Å ÏàòÏùµÎ•†",
                    xaxis_title="ÎÇ†Ïßú",
                    yaxis_title="ÎàÑÏ†Å ÏàòÏùµÎ•†",
                    height=500
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # ÏÑ±Í≥º ÏßÄÌëú ÌëúÏãú
                if 'performance_metrics' in backtest:
                    metrics = backtest['performance_metrics']
                    
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric("Ï¥ù ÏàòÏùµÎ•†", f"{metrics.get('Total Return', 0) * 100:.2f}%")
                    with col2:
                        st.metric("Ïó∞ÏàòÏùµÎ•†", f"{metrics.get('Annualized Return', 0) * 100:.2f}%")
                    with col3:
                        st.metric("ÏÉ§ÌîÑ ÎπÑÏú®", f"{metrics.get('Sharpe Ratio', 0):.3f}")
                    with col4:
                        st.metric("ÏµúÎåÄ ÏÜêÏã§", f"{metrics.get('Max Drawdown', 0) * 100:.2f}%")

# Î©îÏù∏ ÌÅ¥ÎûòÏä§ ÏôÑÎ£å
if __name__ == "__main__":
    st.set_page_config(
        page_title="ÌÜµÌï© ÏïåÌåå Ìå©ÌÑ∞ ÏãúÏä§ÌÖú",
        page_icon="üöÄ", 
        layout="wide"
    )
    
    # ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
    config = UnifiedSystemConfig()
    system = UnifiedAlphaSystem(config)
    
    # ÌÖåÏä§Ìä∏Ïö© Ìã∞Ïª§
    test_tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
    
    # ÏôÑÏ†ÑÌïú Î∂ÑÏÑù Ïã§Ìñâ
    results = system.run_complete_analysis(test_tickers)